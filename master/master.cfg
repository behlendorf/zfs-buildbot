# -*- python -*-
# ex: set syntax=python:

from buildbot.plugins import *
from twisted.python import log
from password import *
from repository import *
from buildslaves import *
from buildbot.buildslave import BuildSlave
from buildbot.plugins import util
from buildbot.schedulers.timed import Nightly

import os.path
import copy
import re

bb_slave_port = 9989
bb_web_port = 8010
zol_url = "http://zfsonlinux.org"
run_url = "http://52.53.197.194/scripts/"
web_url = "http://build.zfsonlinux.org"
pkg_url = "http://download.zfsonlinux.org"
zfs_repo = "https://github.com/tonyhutter/zfs.git"
zfs_path = "/usr/libexec/zfs:/usr/share/zfs:/usr/lib/rpm/zfs:/usr/lib/zfs"
bin_path = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# Provided by CentOS: https://wiki.centos.org/Cloud/AWS
centos6_ami = "ami-ade6e5cd"	# CentOS 6 1-12-2018
centos7_ami = "ami-4826c22b"	# CentOS 7 5-17-2018

# Provided by Fedora: https://alt.fedoraproject.org/cloud/
fedora28_ami = "ami-77b3ae17"          # Fedora 28-1.1
fedora29_ami = "ami-00adf94e8a2f8cb1e" # Fedora 29 04-10-2019
fedora30_ami = "ami-0b03257899cb1d721" # Fedora 30 05-03-2019

c = BuildmasterConfig = {}

c['caches'] = {
    'Changes' : 100,
    'Builds' : 20,
    'chdicts' : 100,
    'BuildRequests' : 10,
    'SourceStamps' : 10,
    'ssdicts' : 20,
    'objectids' : 10,
    'usdicts' : 10,
}

# Keep all changes and the last 20,000 build results per builder.  Only keep
# detailed build logs for the last 2000 builds for each builder (approximately
# the last 6 months of builds).  Individual log files are limited to 10M.
c['changeHorizon'] = 0
c['buildHorizon'] = 20000
c['logHorizon'] = 2000
c['logMaxSize'] = 10*1024*1024 # 10M
c['logMaxTailSize'] = 32768

####### BUILD FACTORIES

# A builder also has a BuildFactory, which is responsible for creating new
# Build instances: because the Build instance is what actually performs each
# build, choosing the BuildFactory is the way to specify what happens each
# time a build is done (Builds).

from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.steps.master import MasterShellCommand
from buildbot.steps.transfer import DirectoryUpload
from buildbot.status.results import SUCCESS
from buildbot.status.results import FAILURE
from buildbot.status.results import WARNINGS
from buildbot.status.results import SKIPPED

def do_step_build(step, name):
    props = step.build.getProperties()

    override_name = 'override-' + name
    if props.hasProperty(override_name):
        m = re.match(r".*yes.*", props[override_name])
        if m is not None:
            return True
        else:
            return False

    if props.hasProperty(name):
        m = re.match(r".*yes.*", props[name])
        if m is not None:
            return True
        else:
            return False
    else:
        return False

def do_step_build_zfs(step):
    return do_step_build(step, 'buildzfs')

def do_step_dependencies(step):
    return do_step_build(step, 'dependencies')

def do_step_upload(step):
    return do_step_build(step, 'upload')

def do_step_stage(step):
    return do_step_build(step, 'stage')

def do_step_test_ztest(step):
    return do_step_build(step, 'testztest')

def do_step_test_zfstests(step):
    return do_step_build(step, 'testzfstests')

def determine_prop(props, name, default):
    override_name = 'override-' + name
    if props.hasProperty(override_name):
        return props[override_name]

    if props.hasProperty(name):
        return props[name]

    return default

@util.renderer
def get_install_method(props):
    return determine_prop(props, 'install', 'none')

@util.renderer
def get_install_upgrade(props):
    return determine_prop(props, 'upgrade', 'no')

@util.renderer
def get_install_testing(props):
    return determine_prop(props, 'testing', 'no')

@util.renderer
def get_version(props):
    if props.hasProperty('commit-description'):
        return props.getProperty('commit-description')['zfs']
    else:
        return ''

@util.renderer
def get_branch_or_pr(props):
    if props.hasProperty('force'):
        return 'artifacts/' + props.getProperty('force')
    elif props.hasProperty('pr_number'):
        return 'artifacts/pull/' + props.getProperty('pr_number')
    elif props.hasProperty('branch'):
        return 'artifacts/branch/' + props.getProperty('branch')
    else:
        return 'artifacts/unknown'

@util.renderer
def get_install_repo(props):
    return determine_prop(props, 'install-repo', pkg_url)

@util.renderer
def get_upgrade_repo(props):
    return determine_prop(props, 'upgrade-repo', pkg_url)

@util.renderer
def get_slave_name(props):
    return determine_prop(props, 'slavename', '')

#
# Package factory - Build packages and run the test suites.
#
# Build release packages Fedora and CentOS, install the packages, and run
# run the request tests.  The tests themselves have been seperated from
# the buildbot configuration to minimize the need for restarting the master.
#
# Only compatible with zfs-0.8.x and newer.
#
package_factory = util.BuildFactory()

package_factory.addStep(ShellCommand(
    env={'PATH' : bin_path},
    command=["runurl", run_url + "bb-package-dependencies.sh"],
    decodeRC={0 : SUCCESS, 1 : FAILURE, 2 : WARNINGS, 3 : SKIPPED },
    haltOnFailure=True, logEnviron=False, lazylogfiles=True,
    description=["installing dependencies"],
    descriptionDone=["installed dependencies"],
    doStepIf = do_step_dependencies,
    hideStepIf=lambda results, s: results==SKIPPED))
package_factory.addStep(Git(repourl=zfs_repo, workdir="build/zfs",
    mode="full", method="clobber", codebase="zfs",
    logEnviron=False, lazylogfiles=True,
    getDescription=True,
    description=["cloning"], descriptionDone=["cloned"],
    doStepIf = do_step_build_zfs,
    hideStepIf=lambda results, s: results==SKIPPED))
package_factory.addStep(ShellCommand(
    env={'PATH' : bin_path,
        'INSTALL_METHOD' : util.Interpolate('%(kw:p)s', p=get_install_method),
        'INSTALL_TESTING' : util.Interpolate('%(kw:p)s', p=get_install_testing),
        'UPLOAD_DIR' : util.Interpolate("/var/tmp/%(kw:p)s/%(kw:q)s",
            p=get_branch_or_pr, q=get_version) },
    workdir="build/zfs",
    command=["runurl", run_url + "bb-package-build.sh"],
    haltOnFailure=True, logEnviron=False, lazylogfiles=True,
    logfiles={"build.log"   : { "filename" : "build.log", "follow" : True },
              "root.log"    : { "filename" : "root.log",    "follow" : True },
              "state.log"   : { "filename" : "state.log",   "follow" : True }},
    decodeRC={0 : SUCCESS, 1 : FAILURE, 2 : WARNINGS, 3 : SKIPPED },
    description=["building zfs"], descriptionDone=["built zfs"],
    doStepIf = do_step_build_zfs,
    hideStepIf=lambda results, s: results==SKIPPED))
package_factory.addStep(ShellCommand(
    env={'PATH' : bin_path,
        'INSTALL_METHOD' : util.Interpolate('%(kw:p)s', p=get_install_method),
        'INSTALL_UPGRADE' : util.Interpolate('%(kw:p)s', p=get_install_upgrade),
        'INSTALL_TESTING' : util.Interpolate('%(kw:p)s', p=get_install_testing),
        'INSTALL_REPO' : util.Interpolate('%(kw:p)s', p=get_install_repo),
        'UPGRADE_REPO' : util.Interpolate('%(kw:p)s', p=get_upgrade_repo),
        'UPLOAD_DIR' : util.Interpolate("/var/tmp/%(kw:p)s/%(kw:q)s",
            p=get_branch_or_pr, q=get_version) },
    workdir="build/zfs",
    command=["runurl", run_url + "bb-package-install.sh"],
    haltOnFailure=True, logEnviron=False, lazylogfiles=True,
    logfiles={"install.log" : { "filename" : "install.log", "follow" : True },
              "upgrade.log" : { "filename" : "upgrade.log", "follow" : True }},
    decodeRC={0 : SUCCESS, 1 : FAILURE, 2 : WARNINGS, 3 : SKIPPED },
    description=["installing zfs"], descriptionDone=["installed zfs"]))
package_factory.addStep(ShellCommand(
    workdir="build/tests",
    env={'PATH' : bin_path + ":" + zfs_path,
        'TEST_METHOD' : util.Interpolate('%(kw:p)s', p=get_install_method),
        'UPLOAD_DIR' : util.Interpolate("/var/tmp/%(kw:p)s/%(kw:q)s",
            p=get_branch_or_pr, q=get_version) },
    command=["runurl", run_url + "bb-test-prepare.sh"],
    haltOnFailure=False, maxTime=120, sigtermTime=30, logEnviron=False,
    lazylogfiles=True,
    logfiles={"test"     : { "filename" : "TEST",        "follow" : False }},
    decodeRC={0 : SUCCESS, 1 : FAILURE, 2 : WARNINGS, 3 : SKIPPED },
    description=["preparing env"], descriptionDone=["prepared env"],
    alwaysRun=True))
package_factory.addStep(ShellCommand(
    workdir="build/tests",
    env={'PATH' : bin_path + ":" + zfs_path,
        'UPLOAD_DIR' : util.Interpolate("/var/tmp/%(kw:p)s/%(kw:q)s",
            p=get_branch_or_pr, q=get_version) },
    command=["runurl", run_url + "bb-test-ztest.sh"],
    haltOnFailure=False, maxTime=14400, sigtermTime=30, logEnviron=False,
    lazylogfiles=True,
    logfiles={"ztest.out" : { "filename" : "ztest.out" },
              "ztest.history" : { "filename" : "ztest.history" },
              "1.ztest.out" : { "filename" : "ztest.core.1/ztest.out" },
              "1.ztest.history" : { "filename" : "ztest.core.1/ztest.history" },
              "1.ztest.zdb" : { "filename" : "ztest.core.1/ztest.zdb" },
              "1.ztest.gdb" : { "filename" : "ztest.core.1/ztest.gdb" }},
    decodeRC={0 : SUCCESS, 1 : FAILURE, 2 : WARNINGS, 3 : SKIPPED },
    description=["ztest"], descriptionDone=["ztest"],
    doStepIf=do_step_test_ztest,
    hideStepIf=lambda results, s: results==SKIPPED))
package_factory.addStep(ShellCommand(
    workdir="build/tests",
    env={'PATH' : bin_path + ":" + zfs_path,
        'UPLOAD_DIR' : util.Interpolate("/var/tmp/%(kw:p)s/%(kw:q)s",
            p=get_branch_or_pr, q=get_version),
        'DEFAULT_ZFSTESTS_RUNFILE' : 'linux',
        'DEFAULT_ZFSTESTS_TAGS' : 'functional'},
    command=["runurl", run_url + "bb-test-zfstests.sh"],
    haltOnFailure=False, flunkOnWarnings=True,
    maxTime=36000, sigtermTime=30, logEnviron=False,
    lazylogfiles=True, timeout=4200,
    logfiles={"console"  : { "filename" : "console.log",  "follow" : True },
              "summary"  : { "filename" : "summary.log",  "follow" : False },
              "tests"    : { "filename" : "test.log",     "follow" : True },
              "log"      : { "filename" : "full.log",     "follow" : True },
              "kmemleak" : { "filename" : "kmemleak.log", "follow" : False }},
    decodeRC={0 : SUCCESS, 1 : FAILURE, 2 : WARNINGS, 3 : SKIPPED },
    description=["zfstests"], descriptionDone=["zfstests"],
    doStepIf=do_step_test_zfstests,
    hideStepIf=lambda results, s: results==SKIPPED))
package_factory.addStep(DirectoryUpload(
    slavesrc=util.Interpolate("/var/tmp/%(kw:p)s/%(kw:q)s",
        p=get_branch_or_pr, q=get_version),
    masterdest=util.Interpolate("public_html/%(kw:p)s/%(kw:q)s",
        p=get_branch_or_pr, q=get_version),
    url=util.Interpolate("%(kw:p)s/%(kw:q)s",
        p=get_branch_or_pr, q=get_version),
    doStepIf=do_step_upload,
    hideStepIf=lambda results, s: results==SKIPPED))
package_factory.addStep(MasterShellCommand(
    env={'PATH' : bin_path + ":/home/buildbot/bin", 'HOME' : "/home/buildbot",
        'INSTALL_METHOD' : util.Interpolate('%(kw:p)s', p=get_install_method),
        'INSTALL_TESTING' : util.Interpolate('%(kw:p)s', p=get_install_testing),
        'BB_NAME' : util.Interpolate('%(kw:p)s', p=get_slave_name),
        'BB_UPLOAD_DIR' : util.Interpolate("public_html/%(kw:p)s/%(kw:q)s",
            p=get_branch_or_pr, q=get_version)},
    command=["runurl", run_url + "bb-package-createrepo.sh"],
    haltOnFailure=True, logEnviron=False,
    description=["creating repository"], descriptionDone=["created repository"],
    doStepIf=do_step_upload,
    hideStepIf=lambda results, s: results==SKIPPED))
package_factory.addStep(MasterShellCommand(
    env={'PATH' : bin_path + ":/home/buildbot/bin", 'HOME' : "/home/buildbot",
        'INSTALL_METHOD' : util.Interpolate('%(kw:p)s', p=get_install_method),
        'INSTALL_TESTING' : util.Interpolate('%(kw:p)s', p=get_install_testing),
        'BB_NAME' : util.Interpolate('%(kw:p)s', p=get_slave_name),
        'BB_UPLOAD_DIR' : util.Interpolate("public_html/%(kw:p)s/%(kw:q)s",
            p=get_branch_or_pr, q=get_version),
        'BB_REPO_DIR' : "public_html/repo"},
    command=["runurl", run_url + "bb-package-stage.sh"],
    haltOnFailure=True, logEnviron=False,
    description=["staging zfs"], descriptionDone=["staged zfs"],
    doStepIf=do_step_stage,
    hideStepIf=lambda results, s: results==SKIPPED))
package_factory.addStep(ShellCommand(
    command=["runurl", run_url + "bb-cleanup.sh"],
    env={'PATH' : bin_path, 'BUILT_PACKAGE' : 'zfs'},
    haltOnFailure=False, logEnviron=False,
    lazylogfiles=True,
    decodeRC={0 : SUCCESS, 1 : FAILURE, 2 : WARNINGS, 3 : SKIPPED },
    description=["removing zfs"], descriptionDone=["removed zfs"]))

####### WORKERS

# Packaging slaves
pkgslaves = 8

centos6_x86_64_pkgslave = [
    ZFSEC2PkgSlave(
        name="CentOS-6-x86_64-testslave%s" % (str(i+1)),
        ami=centos6_ami
    ) for i in range(0, pkgslaves)
]

centos7_x86_64_pkgslave = [
    ZFSEC2PkgSlave(
        name="CentOS-7-x86_64-testslave%s" % (str(i+1)),
        ami=centos7_ami
    ) for i in range(0, pkgslaves)
]

fedora28_x86_64_pkgslave = [
    ZFSEC2PkgSlave(
        name="Fedora-28-x86_64-testslave%s" % (str(i+1)),
        ami=fedora28_ami
    ) for i in range(0, pkgslaves)
]

fedora29_x86_64_pkgslave = [
    ZFSEC2PkgSlave(
        name="Fedora-29-x86_64-testslave%s" % (str(i+1)),
        ami=fedora29_ami
    ) for i in range(0, pkgslaves)
]

fedora30_x86_64_pkgslave = [
    ZFSEC2PkgSlave(
        name="Fedora-30-x86_64-testslave%s" % (str(i+1)),
        ami=fedora30_ami
    ) for i in range(0, pkgslaves)
]

package_slaves = \
    centos6_x86_64_pkgslave + \
    centos7_x86_64_pkgslave + \
    fedora28_x86_64_pkgslave + \
    fedora29_x86_64_pkgslave + \
    fedora30_x86_64_pkgslave


package_tags = [ "Packages" ]


####### BUILDERS

# The Buildmaster runs a collection of Builders, each of which handles a single
# type of build (e.g. full versus quick), on one or more workers. Builders
# serve as a kind of queue for a particular type of build. Each Builder gets a
# separate column in the waterfall display. In general, each Builder runs
# independently (although various kinds of interlocks can cause one Builder
# to have an effect on another).

# Properties are used to control how a build is performed.
builder_nodebug_properties = {
    "buildlinux":    "no",
    "buildzfs":      "yes",
    "builtin":       "no",
    "configspl":     "",
    "configzfs":     "",
    "install":       "packages",
    "upgrade":       "no",
    "testing":       "no",
    "repoowner":     "zfsonlinux",
    "reponame":      "zfs",
    "dependencies":  "yes",
    "upload":        "yes",
    "stage":         "no",
}

def prioritizeBuilders(buildmaster, builders):
    """
    Called by the buildmaster to prioritize the builders.  Returns a sorted
    array of builders designed to improve ec2 utilization. Builders with
    substantiated, idle slaves are given priority. Followed by builders with no
    substantiated slaves. The lowest priority is a builder that is busy.
    This helps keep all buildslaves busy while new latent buildslaves are
    bootstrapped, a process which can take several minutes.
    """

    idle_builders = []
    busy_builders = []
    avail_builders = []

    for b in builders:
        idle = False
        busy = False
        for s in b.slaves:
            if s.isIdle():
               idle = True
               break

            if s.isBusy():
               busy = True

        if idle is True:
            if re.search('BUILD', b.name):
                idle_builders.insert(0, b)
            else:
                idle_builders.append(b)
        elif busy is True:
            if re.search('BUILD', b.name):
                busy_builders.insert(0, b)
            else:
                busy_builders.append(b)
        else:
            if re.search('BUILD', b.name):
                avail_builders.insert(0, b)
            else:
                avail_builders.append(b)

    sorted_builders = idle_builders + avail_builders + busy_builders

    log.msg("prioritized %i builder(s): %s" % (len(sorted_builders),
        [b.name for b in sorted_builders]))

    return sorted_builders

c['prioritizeBuilders'] = prioritizeBuilders

# Package builders
package_builders = [
    ZFSBuilderConfig(
        name="CentOS 6 x86_64 (PACKAGE)",
        factory=package_factory,
        slavenames=[slave.name for slave in centos6_x86_64_pkgslave],
        tags=package_tags,
        properties=builder_nodebug_properties,
    ),
    ZFSBuilderConfig(
        name="CentOS 7 x86_64 (PACKAGE)",
        factory=package_factory,
        slavenames=[slave.name for slave in centos7_x86_64_pkgslave],
        tags=package_tags,
        properties=builder_nodebug_properties,
    ),
    ZFSBuilderConfig(
        name="Fedora 28 x86_64 (PACKAGE)",
        factory=package_factory,
        slavenames=[slave.name for slave in fedora28_x86_64_pkgslave],
        tags=package_tags,
        properties=builder_nodebug_properties,
    ),
    ZFSBuilderConfig(
        name="Fedora 29 x86_64 (PACKAGE)",
        factory=package_factory,
        slavenames=[slave.name for slave in fedora29_x86_64_pkgslave],
        tags=package_tags,
        properties=builder_nodebug_properties,
    ),
    ZFSBuilderConfig(
        name="Fedora 30 x86_64 (PACKAGE)",
        factory=package_factory,
        slavenames=[slave.name for slave in fedora30_x86_64_pkgslave],
        tags=package_tags,
        properties=builder_nodebug_properties,
    ),
]

c['slaves'] = package_slaves
c['builders'] = package_builders


####### CHANGESOURCES

# The 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  For this project all notifications occur via
# a Github webhook.  These can be for branch updates or modifications to
# pull requests (open, reopen, synchronize).  A custom pull request handler
# is used to submit changes for every commit which is part of a pull request.

# The 'protocols' setting contains information about protocols which master
# will use for communicating with slaves.
c['protocols'] = {'pb': {'port': bb_slave_port}}


def codebaseGenerator(chdict):
    return all_repositories[chdict['repository']]

c['codebaseGenerator'] = codebaseGenerator

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.changes.filter import ChangeFilter
from buildbot.changes import filter

package_builders = [builder.name for builder in package_builders]

c['schedulers'] = []
c['schedulers'].append(schedulers.ForceScheduler(
    name="Build Repository Packages",
    builderNames=package_builders,
    buttonName="Build Packages",
    reason=util.FixedParameter(name="reason", default=""),

    codebases=[
        util.CodebaseParameter(
            codebase="zfs",
            label="ZFS Repository",
            branch=util.ChoiceStringParameter(
                name="branch",
                label="Branch:",
                strict=False,
                choices=["zfs-0.8-release", "master"]),

            revision=util.StringParameter(
                name="revision",
                label="Revision:",
                default="zfs-0.8.x",
                size=60),

            repository=util.StringParameter(
                name="repository",
                label="Repository:",
                default=zfs_repo,
                size=60),

            project=util.FixedParameter(name="project", default="zfs"),
        ),
    ],

    # A completely customized property list.  The name of the
    # property is the name of the parameter
    properties=[
        util.FixedParameter(name="force", default="repo"),
        util.ChoiceStringParameter(
            name="install-repo",
            label="Install repository: ",
            choices=["local", pkg_url, "%s/repo" % (web_url)],
            default="local"),
        util.ChoiceStringParameter(
            name="upgrade-repo",
            label="Upgrade repository: ",
            choices=["local", pkg_url, "%s/repo" % (web_url)],
            default="local"),
	# Default testing to "no" once 0.8.0 is released.
        util.ChoiceStringParameter(
            name="override-testing",
            label="Testing repository: ",
            choices=["yes", "no"],
            default="yes"),
        util.ChoiceStringParameter(
            name="override-install",
            label="Package type:",
            choices=["dkms", "kmod-kabi"],
            default="dkms"),
        util.ChoiceStringParameter(
            name="override-upgrade",
            label="Test upgrade:",
            choices=["yes", "no"],
            default="no"),
        util.ChoiceStringParameter(
            name="testztest",
            label="Run ztest:",
            choices=["yes", "no"],
            default="no"),
        util.ChoiceStringParameter(
            name="testzfstests",
            label="Run zfstests:",
            choices=["yes", "no"],
            default="no"),
        util.ChoiceStringParameter(
            name="override-upload",
            label="Upload packages:",
            choices=["yes", "no"],
            default="no"),
	# Requires 'upload=yes'.
        util.ChoiceStringParameter(
            name="override-stage",
            label="Stage packages:",
            choices=["yes", "no"],
            default="no"),
    ]
))

c['schedulers'].append(schedulers.ForceScheduler(
    name="Test Repository Packages",
    builderNames=package_builders,
    buttonName="Test Packages",
    reason=util.FixedParameter(name="reason", default=""),

    codebases=[
        util.CodebaseParameter(
            codebase="zfs",
            label="",
            branch=util.FixedParameter(name="branch", default=""),
            revision=util.FixedParameter(name="revision", default=""),
            repository=util.FixedParameter(name="repository", default=""),
            project=util.FixedParameter(name="project", default="zfs"),
        ),
    ],

    # A completely customized property list.  The name of the
    # property is the name of the parameter
    properties=[
        util.FixedParameter(name="force", default="repo"),
        util.FixedParameter(name="override-dependencies", default="yes"),
        util.FixedParameter(name="override-upload", default="no"),
        util.FixedParameter(name="override-stage", default="no"),
        util.FixedParameter(name="override-buildzfs", default="no"),
        util.ChoiceStringParameter(
            name="install-repo",
            label="Install repository: ",
            choices=[pkg_url, "%s/repo" % (web_url)],
            default=pkg_url),
        util.ChoiceStringParameter(
            name="upgrade-repo",
            label="Upgrade repository: ",
            choices=[pkg_url, "%s/repo" % (web_url)],
            default="%s/repo" % (web_url)),
	# Default testing to "no" once 0.8.0 is released.
        util.ChoiceStringParameter(
            name="override-testing",
            label="Testing repository: ",
            choices=["yes", "no"],
            default="yes"),
        util.ChoiceStringParameter(
            name="override-install",
            label="Package type:",
            choices=["dkms", "kmod-kabi"],
            default="dkms"),
        util.ChoiceStringParameter(
            name="override-upgrade",
            label="Test upgrade:",
            choices=["yes", "no"],
            default="no"),
        util.ChoiceStringParameter(
            name="testztest",
            label="Run ztest:",
            choices=["yes", "no"],
            default="no"),
        util.ChoiceStringParameter(
            name="testzfstests",
            label="Run zfstests:",
            choices=["yes", "no"],
            default="no"),
    ]
))

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz, auth
from buildbot.plugins import status, util

def force_auth(user, status):
    global user_mapping
    for r,users in user_mapping.items():
        if r.match(status.name):
            if user in users:
                return True
    return False

authz_cfg=util.Authz(
    auth=util.BasicAuth(web_userpass),
    gracefulShutdown = False,
    pingBuilder = False,
    pauseSlave = 'auth',
    stopBuild = 'auth',
    stopAllBuilds = 'auth',
    forceBuild = force_auth,
    forceAllBuilds = 'auth',
    cancelPendingBuild = 'auth',
)

c['status'].append(html.WebStatus(http_port=bb_web_port,
    order_console_by_time=True, authz=authz_cfg))


####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "ZFS on Linux (Packages)"
c['titleURL'] = zol_url

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = web_url

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can
    # leave this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
